:sourcedir: ../js

= Teil 3 : Funktionale Programmierung

Die funktionale Programmierung ist eine der großen Stömungen in der Informatik, die sehr oft gegensätzlich zur
imperativen Programmierung angesehen wird. Und tatsächlich sind die Beweggründe der Entstehung sehr konträr.

Während die imperativen Programmiersprachen zu Anfang von Ingenieuren und Physikern entwickelt wurden, um nicht immer die
Bits einzeln in das Register zu laden, entwickelte sich die funktionale Programmierung aus der mathematischen Richtung,
als die Mathematiker erkannten, welches Potential in den aufkommenden elektronischen Rechner steckte.

So entwickelten sich die imperativen Sprachen von ersten Mnemocode-Schnipseln über C und C++ zu moderneren Varianten wie
Java, C# und Go. Die Sprachen abstrahierten dabei immer weiter die darunter liegende technische Schicht und betteten
immer weitere Komfortfeatures ein.

Auf der funktionalen Ebene ging es genau andersherum. Mit dem Lambdakalkül wurde um 1936 zunächst eine formale und mathematische
Basis der funktionalen Programmierung gelegt und mit dem aufkommen der ersten brauchbaren Rechner um 1960 mit Lisp zur
ersten sich durchsetzenden Sprache umgesetzt. Das die Entwickler hier bereits von einer viel höheren Abstraktion kamen
und möglichst nicht viel tiefer in die Technik einsteigen wollten, merkt man an den bereits damals vorhandenen
Komfortfeatures wie der automatischen Speicherreservierung- und bereinigung. Die imperativen Entwickler mussten hier noch
ein paar Jahre warten bis Java mit der virtuelle Maschine daherkam.

Beide Welten kamen sich mit der Zeit immer näher. So basiert z.B. unser heutiges Verständnis der
objektorientierten Programmierung größtenteil auf den Lisp Flavors. Doch blieb der Kernaspekt der funktionalen
Programmierung, das Lambdakalkül, immer reiner Teil der funktionalen Programmiersprachen.

In letzter Zeit flossen die beiden Hauptströmungen nun aber mehr und mehr zusammen und auch die Konstrukte rund um das
Lambdakalkül hielten in die modernen Vertreter der Sprachen ein. Die erste Sprache auf der JVM war Scala, welche
für sich beanspruchte, die Objektorientierung und die funktionale Sprache ganzheitlich zu vereinen.

Neue Sprachen wie Swift liefern direkt die Unterstützung für Funktionen als first class citizen etc. Und selbst die alte
Tante Java hatte das Zeichen der Zeit erkannt und mit Java 8 hielten denn auch Lamdaausdrücke in die Sprache ein.


== Values vs. Variables

Aus imperativen Sprachen kennen wir Variablen als einen benamten, definierten Speicherbereich, der Werte aufnehmen kann.
Der Speicherbereich ist dabei aber nicht fest, sondern kann jederzeit überschrieben werden.

[source,javascript]
----
include::{sourcedir}/deepdive/functional/ValuesAndVariables.js[tags=imperative]
----

Die funktionale Welt kennt keine Varibalen, sondern nur Werte (z.B. `5`) und Funktionen, die lediglich einen Namen
bekommen. Werte sind immer fest und können nicht geändert, sondern nur zur Berechnung herangezogen werden.

[source,javascript]
----
include::{sourcedir}/deepdive/functional/ValuesAndVariables.js[tags=functional]
----

Während also bei imperativen Sprachen zunächst der Speicherbereich definiert und dann mit Werten gefüllt wird,
so wird bei funktionalen Sprachen zunächst ein Wert definiert und ihm dann erst ein Name zugewiesen.

== Was ist eine Funktion?

Da die funktionale Programmierung sich ursprünglich aus der Mathematik entwicklet hat, so sind
auch die Funktionen in solchen Sprachen den der Mathematik eng verbunden.

Eine Funktion hat immer:

* einen oder mehrere Parameter
* ein Ergebnis auf Basis der Parameter

[source,javascript]
----
include::{sourcedir}/deepdive/functional/ToBeOrNotToBeAFunction.js[tags=a_function]
----

Wichtig beim letzten Punkt ist die Einschränkung auf die Eingabeparameter. Funktionen, welche Effekte
außerhalb des Ergebnis haben, bzw. deren Ergebnis von anderen Faktoren, als den Parametern beeinflusst
werden, heißen seiteneffektbehaftet und gelten im strengen Sinne nicht als Funktionen.

[source,javascript]
----
include::{sourcedir}/deepdive/functional/ToBeOrNotToBeAFunction.js[tags=not_a_function]
----

`setY` ist keine Funktion, da sie kein Ergebnis zurück liefert und als Seiteneffekt eine Variable
außerhalb ihres Funktionskörpers ändert.

`sideEffectFunction` ist ebenfalls keine Funktion, da sie `x` auf einem anderen Kanal als dem
Rückgabewert ausgibt und darüber hinaus ihr Ergebnis von `y` beeinflusst wird, welches nicht Teil
ihrer Parameterlist ist.


NOTE:  __Wie trotz dieser Einschränkung IO Operationen wie das `console.log` in der funktionalen Welt statt
findet, sehen wir beim Thema Monaten.__


== Funktionen als first class citizen

In der funktionalen Programmierung bilden Funktionen nicht nur einen zentralen Aspekt für Berechnungen,
sondern gelten wie `Values` als so genannte `first class citizens`. Das bedeutet, dass Funktionen ebenfalls
einem Namen zugewiesen werden können und diese Referenzen wie "normale" `Values` als Parameter und
Rückgabewerte behandelt werden können.

In Javascript können Funktionen im `imperativen` Stil definiert werden. Die Funktion kann dann über den
Namen (hier `add`) aufgerufen, aber auch überall eingesetzt werden.

[source,javascript]
----
include::{sourcedir}/deepdive/functional/FirstClassCitizens.js[tags=classic]
----

Funktionen lassen sich in Javascript aber auch in normalen Variablen oder Konstanden speichern.
Im folgenden Beispiel wird die Funktion `add` in der Konstante `fAdd` gespeichert. Die Funktion lässt sich nun über
die Kostante `fAdd` referenzieren und aufrufen.

Der zweiten Konstante `fAdd2` wird eine anonyme Funktion zugewiesen, die mit der ES6 Syntax geschrieben ist. Die
Funktion kann nun auch hier über die Konstante `fAdd2` aufgerufen werden.
[source,javascript]
----
include::{sourcedir}/deepdive/functional/FirstClassCitizens.js[tags=f_as_val]
----

Das die in Konstanten gespeicherten Funktionen tatsächlich wie normale Werte behandelt werden können, zeigt die
Funktion `usingAFunction`, die ihrerseits eine Funktion (hier `add`) aufnimmt und ihr innerhalb ihres Scopes den Namen
`addFunction` zuweist und worüber die Funktion innerhalb von `usingAFunction` aufgerufen werden kann:

[source,javascript]
----
include::{sourcedir}/deepdive/functional/FirstClassCitizens.js[tags=f_as_param]
----

NOTE:  __Im folgenden werden Funktionen mit der ES6 Syntax definiert. Also z.B.__ `(x, y) => x + y`

== Higher order functions

Da wir in der funktionalen Welt Funktionen als normale Datenelemente betrachten können, ist es auch möglich, Funktionen
anderen Funktionen als Parameter zu übergeben, bzw. neue Funktionen als Ergebnis zurück liefern zu lassen.

Diese Funktionen, welche andere Funktionen verarbeiten können, nennt man *higher order function (HOF)*.

=== Funktionen als Parameter

Zunächst zeigt folgendes Beispiel, wie eine Funktion als Parameter an eine HOF übergeben werden kann:

Definiert ist eine HOF `mapX`, die einen übergebenen Wert `x` auf eine weitere Funktion `xMapper` anwendet, die
ihrerseits als zweiten Paramter an die HOF übergeben wurde.

[source,javascript]
----
include::{sourcedir}/deepdive/functional/HigherOrderFunction.js[tags=function_parameter]
----

`mapX` wird nun mit zwei Parametern, einer Zahl und einer Funktion, aufgerufen. Die Funktion ist in diesem Fall eine
anonyme Funktion, die nur über den Parameter von `mapX` zu einem Namen gelangt. Solche anonymen Funktionen, die
direkt als Paramter übergeben werden, nennt man auch `Lambda-Ausdrücke`.

Lambda-Ausdrücke sieht man z.B. bei Javascript auch in der normalen Collection-API, wie hier bei einem Array.
Über die Methode `map` wird eine Funktion `i => i + 2` übergeben, die alle Elemente des Arrays um `2` erhöht.

[source,javascript]
----
include::{sourcedir}/deepdive/functional/HigherOrderFunction.js[tags=lib_example]
----

=== Funktionen als Ergebnisse

Nachdem wir nun gesehen haben, wie Funktionen an higher-order-functions als Paramter übergeben werden können, fehlen noch
die Funktionen, welche als Berechnungsergebnisse zurück gegeben werden können.

Als Einstieg haben wir eine HOF `getEqualFunction`, die eine Funktion zum Vergleich zweier Werte zurück
liefert. Rufen wir nun `getEqualFunction` auf, so erhalten wir als Ergebnis eine neue Funktion, die ihrerseits mit zwei
Werten aufgerufen werden kann und den eigentlichen Vergleich macht.

[source,javascript]
----
include::{sourcedir}/deepdive/functional/HigherOrderFunction.js[tags=higher_order_function]
----

Eine HOF, die immer eine fest definierte Funktion zurück gibt macht allerdings nicht viel Sinn. Interessant wird
es erst, wenn wir Parameter aus der HOF nehmen, in die neue Funktion einweben und unsere neue Funktion somit
konfigurierbar machen.

Das nächste Beispiel zeigt die HOF `greaterThan`, die einen Paramter `x` annimmt und diesen in eine neue Funktion
einwebt: `(y) => x > y`, welche zurückgegeben wird. Ein Aufrufer kann nun diese den Parameter `y` übergeben, welcher
dann mit dem Wert von `x` aus der Ursprungsfunktion verglichen wird.

Mit diesem Mechanismus können nun beliebig viele Funktionen konfiguriert werden, die immer gegen einen anderen Wert
vergleichen:

[source,javascript]
----
include::{sourcedir}/deepdive/functional/HigherOrderFunction.js[tags=function_builder]
----

== Currying oder Schönfinkeln

== function composition



== Monaden

https://dgronau.wordpress.com/2011/02/03/funktoren-in-java/
https://entropia.de/images/6/63/20100613-monaden.pdf