:sourcedir: ../java

= Final, Volatile, Transient - Was, Wozu und Warum?


== Zunächst: Final als Konstanten

Final als konstante Werte. Jeder Variable wird nur genau einmal gesetzt und kann nicht überschrieben werden.

[source,java]
----
include::{sourcedir}/deepdive/final_transient_volatile/Constant.java[tags=aConstantFinalValue]
----


Final im Kontext eines Klassenattributs. Diese können im Konstuktor initialisiert werden, da dieser bei jeder
Klasseninstanziierung ausgeführt wird.

[source,java]
----
include::{sourcedir}/deepdive/final_transient_volatile/Constant.java[tags=constructor]
----

Das war noch einfach. Nun als kleine Grundlage für die nächsten Themen:

            
== Das Java Memory Model (JMM)

Das JMM ist eine Abstraktion des darunter liegendenden, plattformabhängigen Hardwaremodells.

 +---------------------------+
 |     Java memory model     |
 +---------------------------+
 +---------------------------+
 |   Hardware memory model   |
 +---------------------------+


Im Modell hat jeder Thread seine eigene Ausführungseinheit und besitzt einen Speichercache. Die Hardware hat hier mit
Level 1, 2 und 3 Caches, Hyperthreading etc. ein wesentlich komplexeres Modell, vor dem uns die JVM ein bisschen schützen will.

    THREAD1                                    THREAD2
+-------------+                            +-------------+
|             |       +------------+       |             |
|  +-------+  |       |    MAIN    |       |  +-------+  |
|  |  CPU  |  |       |   MEMORY   |       |  |  CPU  |  |
|  +-------+  |       |            |       |  +-------+  |
|             |       +------------+       |             |
|  +-------+  |             ║              |  +-------+  |
|  | CACHE |  |             ║              |  | CACHE |  |
|  +-------+  |             ║              |  +-------+  |
|            <══════════════╩═══════════════>            |
+-------------+            bus             +-------------+

Beim Threadstart holt sich dieser alle notwendigen Daten aus dem Hauptspeicher in seinen Cache und benutzt
zum Abgleich der Daten zwischen Cache und Hauptspeicher zwei Operationen.

* `flush` Änderungen im Cache werden in den Hauptspeicher zurück geschrieben.
* `refresh` Aktuelle Daten aus dem Hauptspeicher wird in den Cache geladen.

Wann `flush` und `refresh` stattfinden bedingen die komplexen Regeln des JMM. Das bedeutet für uns, dass Änderungen,
die ein Thread an seinen Daten vornimmt, nicht unbedingt sofort in den Hauptspeicher zurückgeschrieben werden.

Damit stellen sich uns aufgrund dieses Modells einige Fragen:

* _Atomicity_: *Welche Operationen sind atomar, d.h. werden nicht durch andere Threads unterbrochen?* +
             Threads werden unterbrochen um Platz für andere Threads zu machen. Manche Operationen brauchen aber einen

* _Ordering_: *In welcher Reihenfolge passieren die Aktionen?* +
            Die Reihenfolge in der ein Tread seine Aktionen abarbeitet muss nicht zwangsläufig von einem anderen Thread
            in dieser Reihenfolge gesehen werden. Compiler, Optimizer, CPUs machen gerne Reorderings, um performanter
            Aktionen auszuführen.

* _Visibility (Sequential Consistency)_: *Wann werden Modifikationen im Speicher anderen Threads sichtbar gemacht?*
            Durch die `flush` und `refresh` Operationen, sehen andere Threads Änderungen an gemeinsam genutzte Variablen
            ggf. sehr viel später.

== Final im nebenläufigen Umfeld
[source,java]
----
include::{sourcedir}/deepdive/final_transient_volatile/FinalConcurrent.java[tags=class]
----


